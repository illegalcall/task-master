# Cursor Tasks for Core Processing Features

Each task should be implemented and tested individually. Only one task is to be implemented at a time; wait for approval and commit before proceeding to the next.

## Initial Job Implementation: SendEmail

- **Task 0.1**: Create basic SendEmail job structure.
  - Define `SendEmailPayload` struct with fields for recipient, subject, body, template name, and attachments
  - Implement JSON schema for payload validation
  - Create sample payloads for testing (welcome email, notification, etc.)
  - **Unit Test**: Verify payload serialization/deserialization works correctly.

- **Task 0.2**: Implement SendEmail job handler.
  - Create `SendEmailHandler` function implementing the `JobHandlerFunc` interface
  - Add support for both plain text and HTML email formats
  - Implement template rendering using Go's template package
  - Add attachment handling with size limits
  - **Unit Test**: Test email sending with a mock SMTP server.
  - **Integration Test**: Verify emails can be sent through a test mail service.

- **Task 0.3**: Add email delivery tracking and reporting.
  - Implement delivery status tracking (sent, delivered, bounced, etc.)
  - Create retry logic specific to email sending failures
  - Add metrics for success rates, delivery times, and bounce rates
  - Implement webhook notifications for email status changes
  - **Unit Test**: Verify tracking logic for different email statuses.
  - **E2E Test**: Test full email workflow including status updates.

## Job Type Registry System
- **Task 1**: Create a `JobRegistry` struct with methods to register job handlers and retrieve them.
  - Implement `RegisterJobType(name string, handler JobHandlerFunc, options JobOptions) error`
  - Implement `GetJobHandler(name string) (JobHandlerFunc, error)`
  - Define `JobHandlerFunc` type as `func(ctx context.Context, payload []byte) (Result, error)`
  - Create validation to prevent duplicate job type registration
  - **Unit Test**: Write tests to verify that registration and retrieval in `JobRegistry` work correctly.
  - **Integration Test**: Verify that registered handlers can be successfully executed.

- **Task 2**: Extend the registry with metadata and discovery capabilities.
  - Add `ListJobTypes() []JobTypeInfo` method
  - Create `JobTypeInfo` struct with fields for name, description, average execution time, and sample payload
  - Implement documentation capabilities via `GetJobDocumentation(name string) JobDocumentation`
  - Add API endpoint `/api/job-types` to expose available job types
  - **Unit Test**: Write tests to verify that listing returns all registered job types with metadata.
  - **E2E Test**: Verify that the API endpoint correctly returns job type information.

- **Task 3**: Implement synchronous job execution interface for legacy systems.
  - Create `ExecuteSync(ctx context.Context, jobType string, payload []byte) (Result, error)` 
  - Implement timeouts and cancellation support for synchronous execution
  - Add logging and metrics for sync vs. async execution
  - **Unit Test**: Verify synchronous execution works with various job types.
  - **Integration Test**: Test integration with simulated legacy system.

## Payload Validation
- **Task 4**: Create a robust payload validation framework.
  - Implement JSON Schema validation for payload structure
  - Add `RegisterPayloadSchema(jobType string, schema string) error`
  - Create validation function `ValidatePayload(jobType string, payload []byte) error`
  - Implement default and custom validation error messages
  - **Unit Test**: Develop tests using sample valid and invalid payloads to ensure robust validation.
  - **Property Test**: Generate random payloads to test validation edge cases.

- **Task 5**: Enhance payload validation with transformation capabilities.
  - Create pipeline for payload normalization before validation
  - Implement versioning for backward compatibility with older payload formats
  - Add payload size limits and sanitization
  - **Unit Test**: Verify that payload transformation works correctly.
  - **Integration Test**: Test with various payload types and versions.

## Configurable Retry Policies
- **Task 6**: Implement comprehensive retry policy configuration.
  - Create `RetryPolicy` struct with fields:
    - `MaxRetries int`
    - `InitialBackoff time.Duration`
    - `MaxBackoff time.Duration`
    - `BackoffMultiplier float64`
    - `RetryableErrors []string` (error types that should trigger retry)
  - Add per job-type default retry configurations
  - Create global retry policy override capabilities
  - **Unit Test**: Write tests to verify that the configuration correctly supplies retry parameters.
  - **Integration Test**: Verify retry policies can be loaded from configuration files.

- **Task 7**: Build adaptive retry mechanism with backoff strategies.
  - Implement exponential backoff algorithm
  - Create jitter function to prevent thundering herd problems
  - Add custom retry decision functions via `ShouldRetry(error) bool`
  - Implement retry attempt tracking and logging
  - **Unit Test**: Write tests to verify that the retry logic correctly handles failures and backoff timing.
  - **Load Test**: Verify backoff behavior under high concurrency.

- **Task 8**: Implement retry history and analytics.
  - Store retry attempts with timestamps and error messages
  - Create API endpoint `/api/jobs/:id/retry-history`
  - Add metrics for retry success/failure rates by job type
  - Implement alerting for jobs exceeding retry thresholds
  - **Unit Test**: Verify retry history recording works correctly.
  - **E2E Test**: Test API endpoint for retry history.

## Job Timeout Handling
- **Task 9**: Implement multi-level timeout management.
  - Create `TimeoutConfig` struct with fields:
    - `DefaultTimeout time.Duration`
    - `MaxTimeout time.Duration`
    - `WarningThreshold time.Duration` (for alerting)
  - Implement per job-type timeout configurations
  - Add timeout override capability when submitting jobs
  - **Unit Test**: Create tests for timeout configuration loading and validation.
  - **Integration Test**: Verify timeout configuration is correctly applied.

- **Task 10**: Build graceful timeout handling for workers.
  - Implement context-based timeout propagation
  - Create cleanup handlers for timed-out jobs
  - Add system for graceful shutdown of long-running tasks
  - Implement resource cleanup for interrupted jobs
  - **Unit Test**: Create tests to simulate timeout scenarios and verify that jobs are cancelled as expected.
  - **Stress Test**: Verify timeout behavior under high load conditions.

- **Task 11**: Create timeout observability and monitoring.
  - Implement timeout event logging with detailed diagnostics
  - Add metrics for job timeout frequency by type
  - Create dashboard widgets for timeout visualization
  - Implement alerting for abnormal timeout patterns
  - **Unit Test**: Verify monitoring correctly captures timeout events.
  - **E2E Test**: Test dashboard with simulated timeout scenarios.

## Progress Tracking
- **Task 12**: Implement fine-grained progress reporting system.
  - Create `ReportProgress(jobID string, percentage float64, message string) error`
  - Implement `GetProgress(jobID string) (JobProgress, error)`
  - Design `JobProgress` struct with fields for percentage, stage, message, and timestamp
  - Add support for stage-based progress (e.g., "Downloading: 50%", "Processing: 20%")
  - **Unit Test**: Write tests to ensure that progress updates and retrieval function correctly.
  - **Integration Test**: Verify progress updates work end-to-end.

- **Task 13**: Build real-time progress notification system.
  - Implement WebSocket endpoint for progress updates
  - Create Redis pub/sub channel for progress events
  - Add progress event history with timestamp retention
  - Implement throttling for high-frequency progress updates
  - **Unit Test**: Verify pub/sub functionality for progress updates.
  - **Load Test**: Test progress reporting under high frequency updates.

- **Task 14**: Enhance UI for progress monitoring.
  - Create API endpoint `/api/jobs/:id/progress`
  - Implement progress visualization components
  - Add ETA calculation based on progress rate
  - Design progress history view with timeline
  - **Unit Test**: Develop tests to verify the endpoint returns accurate progress data.
  - **E2E Test**: Test progress visualization with simulated jobs.

## Job Dependencies
- **Task 15**: Design and implement job dependency framework.
  - Create `DependencyConfig` struct with fields:
    - `DependsOn []string` (job IDs)
    - `DependencyType string` (e.g., "all", "any", "custom")
    - `FailureAction string` (e.g., "abort", "continue", "retry")
  - Implement dependency validation on job submission
  - Create dependency resolution system for job scheduler
  - Add cycle detection for circular dependencies
  - **Unit Test**: Write tests to validate dependency configuration and resolution.
  - **Integration Test**: Test dependency chains with varying conditions.

- **Task 16**: Implement advanced dependency features.
  - Create conditional dependencies (run if parent succeeded/failed)
  - Implement timeout handling for stuck dependencies
  - Add cross-queue dependencies capability
  - Create visualization for dependency graphs
  - **Unit Test**: Verify conditional dependency logic.
  - **E2E Test**: Test complex dependency scenarios.

- **Task 17**: Build dependency management APIs.
  - Create API endpoints for:
    - `/api/jobs/:id/dependencies` (GET, POST, DELETE)
    - `/api/jobs/:id/dependents` (GET)
  - Implement dependency modification for queued jobs
  - Add bulk dependency operations
  - Create dependency audit logging
  - **Unit Test**: Verify API endpoints function correctly.
  - **Integration Test**: Test dependency modification through API.

## Job Cancellation
- **Task 18**: Implement comprehensive cancellation system.
  - Create `CancelJob(jobID string, reason string) error`
  - Implement graceful and forced cancellation modes
  - Add per job-type cancellation handlers
  - Create cancellation propagation to dependent jobs
  - **Unit Test**: Write tests to simulate job cancellation and verify proper behavior.
  - **Integration Test**: Test cancellation across distributed workers.

- **Task 19**: Enhance cancellation with user control features.
  - Implement cancellation permission system
  - Create API endpoint `/api/jobs/:id/cancel`
  - Add cancellation reason tracking and auditing
  - Implement cancellation webhooks for notification
  - **Unit Test**: Verify permission checks for cancellation.
  - **E2E Test**: Test cancellation flow through API.

- **Task 20**: Build cancellation recovery mechanisms.
  - Implement partial result saving for cancelled jobs
  - Create system for resuming cancelled jobs
  - Add cleanup for resources from cancelled jobs
  - Implement metrics for cancellation patterns
  - **Unit Test**: Verify resource cleanup after cancellation.
  - **Integration Test**: Test job resumption after cancellation.

## Priority Queues
- **Task 21**: Design priority system architecture.
  - Create `Priority` enum with levels (e.g., Low, Normal, High, Critical)
  - Implement priority field in job submission API
  - Add priority inheritance for dependent jobs
  - Create priority boost mechanisms for aging jobs
  - **Unit Test**: Write tests to verify that priority information is correctly stored.
  - **Integration Test**: Verify priority settings are preserved throughout job lifecycle.

- **Task 22**: Implement priority-based scheduling.
  - Modify Kafka producer to use partitioned topics by priority
  - Create priority-aware consumer groups
  - Implement fair scheduling to prevent starvation
  - Add dynamic priority adjustment based on wait time
  - **Unit Test**: Develop tests to ensure that jobs with higher priority are processed before lower priority ones.
  - **Load Test**: Verify priority scheduling under high queue depth.

- **Task 23**: Build priority management and monitoring.
  - Create API endpoints for priority management
  - Implement priority override for administrators
  - Add metrics for priority distribution and wait times
  - Create alerts for blocked high-priority jobs
  - **Unit Test**: Verify priority management API functions.
  - **E2E Test**: Test priority visualization and management in UI.

## Dead-letter Queue
- **Task 24**: Implement comprehensive dead-letter queue system.
  - Create dead-letter queue in Kafka
  - Implement `MoveToDeadLetter(jobID string, reason string) error`
  - Add configurable policies for when to dead-letter
  - Create metadata enrichment for dead-lettered jobs
  - **Unit Test**: Write tests to verify that failed jobs are correctly moved to the dead-letter queue.
  - **Integration Test**: Test end-to-end dead-letter flow.

- **Task 25**: Build dead-letter management capabilities.
  - Create API endpoints:
    - `/api/dead-letter` (GET, filtering options)
    - `/api/dead-letter/:id/replay`
    - `/api/dead-letter/:id/discard`
  - Implement batch operations for dead-letter management
  - Add replay with modified payload capability
  - Create notification system for dead-letter events
  - **Unit Test**: Verify dead-letter management API functions.
  - **E2E Test**: Test dead-letter UI workflows.

- **Task 26**: Enhance dead-letter analytics and diagnosis.
  - Implement root cause analysis for dead-lettered jobs
  - Create pattern detection for recurring failures
  - Add dead-letter trend analysis and visualization
  - Implement auto-categorization of failure reasons
  - **Unit Test**: Verify analytics functions correctly.
  - **Integration Test**: Test pattern detection with simulated failures.

## Result Storage
- **Task 27**: Design flexible result storage architecture.
  - Create `Result` interface with implementations:
    - `SimpleResult` (string/JSON result)
    - `BinaryResult` (file/blob result)
    - `ReferenceResult` (pointer to external system)
  - Implement result type negotiation system
  - Add result schema validation capabilities
  - Create result metadata system with tags
  - **Unit Test**: Write tests to ensure the schema can accommodate required data.
  - **Integration Test**: Test with various result types.

- **Task 28**: Implement efficient result storage backends.
  - Create PostgreSQL storage for structured results
  - Implement file/S3 storage for large results
  - Add Redis caching for frequent access results
  - Create result storage rotation and cleanup policies
  - **Unit Test**: Verify result storage and retrieval functions.
  - **Performance Test**: Test large result handling efficiency.

- **Task 29**: Build result management and access APIs.
  - Create API endpoints:
    - `/api/jobs/:id/result`
    - `/api/jobs/:id/result/download`
  - Implement result transformation for different formats
  - Add access control for sensitive results
  - Create result streaming for large payloads
  - **Unit Test**: Develop tests to verify result API endpoints.
  - **E2E Test**: Test result visualization and download from UI.

## Web UI Integration
- **Task 30**: Design and implement comprehensive job management UI.
  - Create job submission form with dynamic fields based on job type
  - Implement real-time job status dashboard with WebSocket updates
  - Add detailed job view with progress, logs, and result visualization
  - Create admin tools for system management
  - **Unit Test**: Verify UI components render correctly.
  - **E2E Test**: Test full user workflows through UI.

## Legacy System Integration
- **Task 31**: Build legacy system integration layer.
  - Create client library with synchronous API compatibility
  - Implement optional callback mechanisms for completion notification
  - Add transparent conversion between sync/async models
  - Create connection pooling and throttling for legacy systems
  - **Unit Test**: Verify client library functions.
  - **Integration Test**: Test with simulated legacy system.

- **Task 32**: Enhance library integration with advanced features.
  - Implement circuit breaker pattern for system protection
  - Create graceful degradation to synchronous mode on queue failures
  - Add transparent retries for legacy system integration
  - Implement detailed logging for troubleshooting
  - **Unit Test**: Verify circuit breaker behavior.
  - **Load Test**: Test behavior under failure conditions.